//==============================================================================
//  WARNING!!  This file is overwritten by the Block UI Styler while generating
//  the automation code. Any modifications to this file will be lost after
//  generating the code again.
//
//       Filename:  C:\ug_customization\application\dialogs\tunnel+slot\tunnelslot.cs
//
//        This file was generated by the NX Block UI Styler
//        Created by: USP
//              Version: NX 7.5
//              Date: 06-03-2013  (Format: mm-dd-yyyy)
//              Time: 17:38 (Format: hh-mm)
//
//==============================================================================

//==============================================================================
//  Purpose:  This TEMPLATE file contains C# source to guide you in the
//  construction of your Block application dialog. The generation of your
//  dialog file (.dlx extension) is the first step towards dialog construction
//  within NX.  You must now create a NX Open application that
//  utilizes this file (.dlx).
//
//  The information in this file provides you with the following:
//
//  1.  Help on how to load and display your Block UI Styler dialog in NX
//      using APIs provided in NXOpen.BlockStyler namespace
//  2.  The empty callback methods (stubs) associated with your dialog items
//      have also been placed in this file. These empty methods have been
//      created simply to start you along with your coding requirements.
//      The method name, argument list and possible return values have already
//      been provided for you.
//==============================================================================

//------------------------------------------------------------------------------
//These imports are needed for the following template code
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Collections.Generic;
using NXOpen;
using NXOpen.Assemblies;
using NXOpen.BlockStyler;

//------------------------------------------------------------------------------
//Represents Block Styler application class
//------------------------------------------------------------------------------
// ReSharper disable UnusedMember.Global
public class Tunnelslot
// ReSharper restore UnusedMember.Global
{
    //class members
    private static Tunnelslot _thetunnelslot;
    private readonly string _theDialogName;
    private BlockDialog _theDialog;
    private UIBlock _selection0;// Block type: Selection
    private UIBlock _faceSelect0;// Block type: Face Collector
    private UIBlock _direction0;// Block type: Position
    private UIBlock _selection01;// Block type: Selection
    private UIBlock _point0;// Block type: Specify Point
    private UIBlock _slotTunPoint;

    //------------------------------------------------------------------------------
    //Bit Option for Property: SnapPointTypesEnabled
    //------------------------------------------------------------------------------
    //public static readonly int              SnapPointTypesEnabled_UserDefined = (1 << 0);
    //public static readonly int                 SnapPointTypesEnabled_Inferred = (1 << 1);
    //public static readonly int           SnapPointTypesEnabled_ScreenPosition = (1 << 2);
    //public static readonly int                 SnapPointTypesEnabled_EndPoint = (1 << 3);
    //public static readonly int                 SnapPointTypesEnabled_MidPoint = (1 << 4);
    //public static readonly int             SnapPointTypesEnabled_ControlPoint = (1 << 5);
    //public static readonly int             SnapPointTypesEnabled_Intersection = (1 << 6);
    //public static readonly int                SnapPointTypesEnabled_ArcCenter = (1 << 7);
    //public static readonly int            SnapPointTypesEnabled_QuadrantPoint = (1 << 8);
    //public static readonly int            SnapPointTypesEnabled_ExistingPoint = (1 << 9);
    //public static readonly int             SnapPointTypesEnabled_PointonCurve = (1 <<10);
    //public static readonly int           SnapPointTypesEnabled_PointonSurface = (1 <<11);
    //public static readonly int         SnapPointTypesEnabled_PointConstructor = (1 <<12);
    //public static readonly int     SnapPointTypesEnabled_TwocurveIntersection = (1 <<13);
    //public static readonly int             SnapPointTypesEnabled_TangentPoint = (1 <<14);
    //public static readonly int                    SnapPointTypesEnabled_Poles = (1 <<15);
    //public static readonly int         SnapPointTypesEnabled_BoundedGridPoint = (1 <<16);
    ////------------------------------------------------------------------------------
    ////Bit Option for Property: SnapPointTypesOnByDefault
    ////------------------------------------------------------------------------------
    //public static readonly int          SnapPointTypesOnByDefault_UserDefined = (1 << 0);
    //public static readonly int             SnapPointTypesOnByDefault_Inferred = (1 << 1);
    //public static readonly int       SnapPointTypesOnByDefault_ScreenPosition = (1 << 2);
    //public static readonly int             SnapPointTypesOnByDefault_EndPoint = (1 << 3);
    //public static readonly int             SnapPointTypesOnByDefault_MidPoint = (1 << 4);
    //public static readonly int         SnapPointTypesOnByDefault_ControlPoint = (1 << 5);
    //public static readonly int         SnapPointTypesOnByDefault_Intersection = (1 << 6);
    //public static readonly int            SnapPointTypesOnByDefault_ArcCenter = (1 << 7);
    //public static readonly int        SnapPointTypesOnByDefault_QuadrantPoint = (1 << 8);
    //public static readonly int        SnapPointTypesOnByDefault_ExistingPoint = (1 << 9);
    //public static readonly int         SnapPointTypesOnByDefault_PointonCurve = (1 <<10);
    //public static readonly int       SnapPointTypesOnByDefault_PointonSurface = (1 <<11);
    //public static readonly int     SnapPointTypesOnByDefault_PointConstructor = (1 <<12);
    //public static readonly int SnapPointTypesOnByDefault_TwocurveIntersection = (1 <<13);
    //public static readonly int         SnapPointTypesOnByDefault_TangentPoint = (1 <<14);
    //public static readonly int                SnapPointTypesOnByDefault_Poles = (1 <<15);
    //public static readonly int     SnapPointTypesOnByDefault_BoundedGridPoint = (1 <<16);
    ////------------------------------------------------------------------------------
    ////Bit Option for Property: EntityType
    ////------------------------------------------------------------------------------
    //public static readonly int                          EntityType_AllowFaces = (1 << 4);
    //public static readonly int                         EntityType_AllowDatums = (1 << 5);
    //public static readonly int                         EntityType_AllowBodies = (1 << 6);
    ////------------------------------------------------------------------------------
    ////Bit Option for Property: FaceRules
    ////------------------------------------------------------------------------------
    //public static readonly int                           FaceRules_SingleFace = (1 << 0);
    //public static readonly int                          FaceRules_RegionFaces = (1 << 1);
    //public static readonly int                         FaceRules_TangentFaces = (1 << 2);
    //public static readonly int                   FaceRules_TangentRegionFaces = (1 << 3);
    //public static readonly int                            FaceRules_BodyFaces = (1 << 4);
    //public static readonly int                         FaceRules_FeatureFaces = (1 << 5);
    //public static readonly int                        FaceRules_AdjacentFaces = (1 << 6);
    //public static readonly int                  FaceRules_ConnectedBlendFaces = (1 << 7);
    //public static readonly int                        FaceRules_AllBlendFaces = (1 << 8);
    //public static readonly int                             FaceRules_RibFaces = (1 << 9);
    //public static readonly int                            FaceRules_SlotFaces = (1 <<10);
    //public static readonly int                   FaceRules_BossandPocketFaces = (1 <<11);
    //public static readonly int                       FaceRules_MergedRibFaces = (1 <<12);
    //public static readonly int                  FaceRules_RegionBoundaryFaces = (1 <<13);
    //public static readonly int                 FaceRules_FaceandAdjacentFaces = (1 <<14);

    
    //---------------------------------------------------------------------------------

    UspElement _element1, _element2;
    Tunnel _tunnel1;
    SlotSet _slotSet1, _slotSet2;
    static Slot _slot1;
    static Slot _slot2;

    private TunnelSlotConstraint _constraint;

    static bool _secondPointSelected;
    static bool _firstPointSelected;

    private static bool _hasNearestSlot1;
    private static bool _hasNearestSlot2;

    //------------------------------------------------------------------------------
    //Constructor for NX Styler class
    //------------------------------------------------------------------------------
    public Tunnelslot()
    {
        try
        {
            _theDialogName = AppDomain.CurrentDomain.BaseDirectory +
                Config.DlxFolder + Path.DirectorySeparatorChar + Config.DlxTunnelSlot;

            _theDialog = Config.TheUi.CreateDialog(_theDialogName);
            _theDialog.AddApplyHandler(apply_cb);
            _theDialog.AddOkHandler(ok_cb);
            _theDialog.AddUpdateHandler(update_cb);
            _theDialog.AddCancelHandler(cancel_cb);
            _theDialog.AddFilterHandler(filter_cb);
            _theDialog.AddInitializeHandler(initialize_cb);
            _theDialog.AddFocusNotifyHandler(focusNotify_cb);
            _theDialog.AddKeyboardFocusNotifyHandler(keyboardFocusNotify_cb);
            _theDialog.AddDialogShownHandler(dialogShown_cb);
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            throw ex;
        }
    }
    //------------------------------- DIALOG LAUNCHING ---------------------------------
    //
    //    Before invoking this application one needs to open any part/empty part in NX
    //    because of the behavior of the blocks.
    //
    //    Make sure the dlx file is in one of the following locations:
    //        1.) From where NX session is launched
    //        2.) $UGII_USER_DIR/application
    //        3.) For released applications, using UGII_CUSTOM_DIRECTORY_FILE is highly
    //            recommended. This variable is set to a full directory path to a file 
    //            containing a list of root directories for all custom applications.
    //            e.g., UGII_CUSTOM_DIRECTORY_FILE=$UGII_ROOT_DIR\menus\custom_dirs.dat
    //
    //    You can create the dialog using one of the following way:
    //
    //    1. Journal Replay
    //
    //        1) Replay this file through Tool->Journal->Play Menu.
    //
    //    2. USER EXIT
    //
    //        1) Remove the following conditional definitions:
    //                a) #if USER_EXIT_OR_MENU
    //                    #endif//USER_EXIT_OR_MENU
    //
    //                b) #if USER_EXIT
    //                    #endif//USER_EXIT
    //        2) Create the Shared Library -- Refer "Block UI Styler programmer's guide"
    //        3) Invoke the Shared Library through File->Execute->NX Open menu.
    //
    //    3. THROUGH CALLBACK OF ANOTHER DIALOG
    //
    //        1) Remove the following conditional definition:
    //             #if CALLBACK
    //             #endif//CALLBACK
    //        2) Call the following line of code from where ever you want to lauch this dialog.
    //             tunnelslot.Show_tunnelslot();
    //        3) Integrate this file with your main application file.
    //
    //    4. MENU BAR
    //    
    //        1) Remove the following conditional definition:
    //                a) #if USER_EXIT_OR_MENU
    //                   #endif//USER_EXIT_OR_MENU
    //        2) Add the following lines to your MenuScript file in order to
    //           associate a menu bar button with your dialog.  In this
    //           example, a cascade menu will be created and will be
    //           located just before the Help button on the main menubar.
    //           The button, SAMPLEVB_BTN is set up to launch your dialog and
    //           will be positioned as the first button on your pulldown menu.
    //           If you wish to add the button to an existing cascade, simply
    //           add the 3 lines between MENU LAUNCH_CASCADE and END_OF_MENU
    //           to your menuscript file.
    //           The MenuScript file requires an extension of ".men".
    //           Move the contents between the dashed lines to your Menuscript file.
    //        
    //           !-----------------------------------------------------------------------------
    //           VERSION 120
    //        
    //           EDIT UG_GATEWAY_MAIN_MENUBAR
    //        
    //           BEFORE UG_HELP
    //           CASCADE_BUTTON BLOCKSTYLER_DLX_CASCADE_BTN
    //           LABEL Dialog Launcher
    //           END_OF_BEFORE
    //        
    //           MENU BLOCKSTYLER_DLX_CASCADE_BTN
    //           BUTTON SAMPLEVB_BTN
    //           LABEL Display SampleVB dialog
    //           ACTIONS <path of Shared library> !For example: D:\temp\SampleVB.dll
    //           END_OF_MENU
    //           !-----------------------------------------------------------------------------
    //        
    //        3) Make sure the .men file is in one of the following locations:
    //        
    //           - $UGII_USER_DIR/startup   
    //           - For released applications, using UGII_CUSTOM_DIRECTORY_FILE is highly
    //             recommended. This variable is set to a full directory path to a file 
    //             containing a list of root directories for all custom applications.
    //             e.g., UGII_CUSTOM_DIRECTORY_FILE=$UGII_ROOT_DIR\menus\custom_dirs.dat
    //    
    //------------------------------------------------------------------------------
//#if USER_EXIT_OR_MENU
// ReSharper disable UnusedMember.Global
    public static void Main()
// ReSharper restore UnusedMember.Global
    {
        try
        {
            Logger.WriteLine("++++++++++++++++++++++++++++++++++++++++++++++++" + " Начало работы программы");
            _thetunnelslot = new Tunnelslot();
            // The following method shows the dialog immediately
            _thetunnelslot.Show();
            Logger.WriteLine("-------------------------------------------------" + " Конец работы программы");
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            Config.TheUi.NXMessageBox.Show("Block Styler", NXMessageBox.DialogType.Error, ex.ToString());
        }
        finally
        {
            _thetunnelslot.Dispose();
        }
    }
//#endif//USER_EXIT_OR_MENU
//#if USER_EXIT
    //------------------------------------------------------------------------------
    // This method specifies how a shared image is unloaded from memory
    // within NX. This method gives you the capability to unload an
    // internal NX Open application or user  exit from NX. Specify any
    // one of the three constants as a return value to determine the type
    // of unload to perform:
    //
    //
    //    Immediately : unload the library as soon as the automation program has completed
    //    Explicitly  : unload the library from the "Unload Shared Image" dialog
    //    AtTermination : unload the library when the NX session terminates
    //
    //
    // NOTE:  A program which associates NX Open applications with the menubar
    // MUST NOT use this option since it will UNLOAD your NX Open application image
    // from the menubar.
    //------------------------------------------------------------------------------
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedParameter.Global
     public static int GetUnloadOption(string arg)
// ReSharper restore UnusedParameter.Global
// ReSharper restore UnusedMember.Global
    {
         return Convert.ToInt32(Session.LibraryUnloadOption.Immediately);
    }
    
    //------------------------------------------------------------------------------
    // Following method cleanup any housekeeping chores that may be needed.
    // This method is automatically called by NX.
    //------------------------------------------------------------------------------
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedParameter.Global
    public static int UnloadLibrary(string arg)
// ReSharper restore UnusedParameter.Global
// ReSharper restore UnusedMember.Global
    {
        try
        {
            //---- Enter your code here -----
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            Config.TheUi.NXMessageBox.Show("Block Styler", NXMessageBox.DialogType.Error, ex.ToString());
        }
        return 0;
    }
//#endif//USER_EXIT
    
    //------------------------------------------------------------------------------
    //This method shows the dialog on the screen
    //------------------------------------------------------------------------------
    private void Show()
    {
        try
        {
            _theDialog.Show();
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            Config.TheUi.NXMessageBox.Show("Block Styler", NXMessageBox.DialogType.Error, ex.ToString());
        }
    }

    //------------------------------------------------------------------------------
    //Method Name: Dispose
    //------------------------------------------------------------------------------
    private void Dispose()
    {
        CleanUp();

        if(_theDialog != null)
        {
            _theDialog.Dispose();
            _theDialog = null;
        }
    }
    
//#if CALLBACK
    //------------------------------------------------------------------------------
    //Method name: Show_tunnelslot
    //------------------------------------------------------------------------------
// ReSharper disable UnusedMember.Global
    public static void Show_tunnelslot()
// ReSharper restore UnusedMember.Global
    {
        try
        {
            _thetunnelslot = new Tunnelslot();
            // The following method shows the dialog immediately
            _thetunnelslot.Show();
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            Config.TheUi.NXMessageBox.Show("Block Styler", NXMessageBox.DialogType.Error, ex.ToString());
        }
        finally
        {
            _thetunnelslot.Dispose();
        }
    }
//#endif//CALLBACK
    
    //------------------------------------------------------------------------------
    //---------------------Block UI Styler Callback Functions--------------------------
    //------------------------------------------------------------------------------
    
    //------------------------------------------------------------------------------
    //Callback Name: initialize_cb
    //------------------------------------------------------------------------------
    private void initialize_cb()
    {
        try
        {
            _selection0 = _theDialog.TopBlock.FindBlock("selection0");
            _faceSelect0 = _theDialog.TopBlock.FindBlock("face_select0");
            _slotTunPoint = _theDialog.TopBlock.FindBlock("point01");
            _direction0 = _theDialog.TopBlock.FindBlock("direction0");
            _selection01 = _theDialog.TopBlock.FindBlock("selection01");
            _point0 = _theDialog.TopBlock.FindBlock("point0");
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            Config.TheUi.NXMessageBox.Show("Block Styler", NXMessageBox.DialogType.Error, ex.ToString());
        }
    }
    
    //------------------------------------------------------------------------------
    //Callback Name: dialogShown_cb
    //This callback is executed just before the dialog launch. Thus any value set 
    //here will take precedence and dialog will be launched showing that value. 
    //------------------------------------------------------------------------------
    private static void dialogShown_cb()
    {
        try
        {
            //---- Enter your callback code here -----
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            Config.TheUi.NXMessageBox.Show("Block Styler", NXMessageBox.DialogType.Error, ex.ToString());
        }
    }
    
    //------------------------------------------------------------------------------
    //Callback Name: apply_cb
    //------------------------------------------------------------------------------
    private static int apply_cb()
    {
        int errorCode = 0;
        try
        {
            //---- Enter your callback code here -----
            Logger.WriteLine("Нажата кнопка ПРИМЕНИТЬ.");
            CleanUp();
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            errorCode = 1;
            Config.TheUi.NXMessageBox.Show("Block Styler", NXMessageBox.DialogType.Error, ex.ToString());
            Logger.WriteError(ex.ToString());
        }
        return errorCode;
    }
    
    //------------------------------------------------------------------------------
    //Callback Name: update_cb
    //------------------------------------------------------------------------------
    private int update_cb( UIBlock block)
    {
        try
        {
            if(block == _selection0)
            {
            //---------Enter your code here-----------
                Logger.WriteLine("Нажат выбор объекта по первому select.");
                SetFirstComponent(block);
            }
            else if(block == _faceSelect0)
            {
            //---------Enter your code here-----------
                Logger.WriteLine("Нажат выбор первой грани.");
                SetFirstFace(block);
            }
            else if (block == _slotTunPoint)
            {
                //---------Enter your code here-----------
                Logger.WriteLine("Нажата постановка первой точки.");
                SetFirstPoint(block);
            }
            else if (block == _direction0)
            {
                //---------Enter your code here-----------
                Logger.WriteLine("Нажат реверс.");
                _constraint.Reverse();
            }
            else if(block == _selection01)
            {
            //---------Enter your code here-----------
                Logger.WriteLine("Нажат выбор объекта по второму select.");
                SetSecondComponent(block);
            }
            else if(block == _point0)
            {
            //---------Enter your code here-----------
                Logger.WriteLine("Нажата постановка второй точки.");
                SetSecondPoint(block);
            }
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            Config.TheUi.NXMessageBox.Show("Block Styler", NXMessageBox.DialogType.Error, ex.ToString());
            Logger.WriteError(ex.ToString());
        }
        return 0;
    }
    
    //------------------------------------------------------------------------------
    //Callback Name: ok_cb
    //------------------------------------------------------------------------------
    private static int ok_cb()
    {
        int errorCode = 0;
        try
        {
            errorCode = apply_cb();
            //---- Enter your callback code here -----
            Logger.WriteLine("Нажата кнопка ОК.");
            CleanUp();
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            errorCode = 1;
            Config.TheUi.NXMessageBox.Show("Block Styler", NXMessageBox.DialogType.Error, ex.ToString());
            Logger.WriteError(ex.ToString());
        }
        return errorCode;
    }
    
    //------------------------------------------------------------------------------
    //Callback Name: cancel_cb
    //------------------------------------------------------------------------------
    private static int cancel_cb()
    {
        try
        {
            //---- Enter your callback code here -----
            Logger.WriteLine("Нажата кнопка ОТМЕНА.");
            CleanUp();
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            Config.TheUi.NXMessageBox.Show("Block Styler", NXMessageBox.DialogType.Error, ex.ToString());
            Logger.WriteError(ex.ToString());
        }
        return 0;
    }
    
    //------------------------------------------------------------------------------
    //Callback Name: filter_cb
    //------------------------------------------------------------------------------
    private static int filter_cb(UIBlock block, TaggedObject selectedObject)
    {
        return(NXOpen.UF.UFConstants.UF_UI_SEL_ACCEPT);
    }
    
    //------------------------------------------------------------------------------
    //Callback Name: focusNotify_cb
    //This callback is executed when any block (except the ones which receive keyboard entry such as Integer block) receives focus.
    //------------------------------------------------------------------------------
    private static void focusNotify_cb(UIBlock block, bool focus)
    {
        try
        {
            //---- Enter your callback code here -----
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            Config.TheUi.NXMessageBox.Show("Block Styler", NXMessageBox.DialogType.Error, ex.ToString());
        }
    }
    
    //------------------------------------------------------------------------------
    //Callback Name: keyboardFocusNotify_cb
    //This callback is executed when block which can receive keyboard entry, receives the focus.
    //------------------------------------------------------------------------------
    private static void keyboardFocusNotify_cb(UIBlock block, bool focus)
    {
        try
        {
            //---- Enter your callback code here -----
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            Config.TheUi.NXMessageBox.Show("Block Styler", NXMessageBox.DialogType.Error, ex.ToString());
        }
    }

    //--------------------------------------------------------------------

    void SetFirstComponent(UIBlock block)
    {
        if (SetComponent(block, ref _element1))
        {
            SetEnable(_faceSelect0, true);

            _slotSet1 = new SlotSet(_element1);
            _element1.SetBottomFaces();
        }
        else
        {
            SetEnable(_faceSelect0, false);
        }
        SetEnable(_direction0, false);
        UnSelectSlot(_slot1, _slotTunPoint);
        _firstPointSelected = false;
        UnSelectObjects(_faceSelect0);
    }
    void SetSecondComponent(UIBlock block)
    {
        if (SetComponent(block, ref _element2))
        {
            SetEnable(_point0, true);
            _slotSet2 = new SlotSet(_element2);
            _element2.SetBottomFaces();
        }
        else
        {
            SetEnable(_point0, false);
        }
        _secondPointSelected = false;
        if (_slot2 != null)
        {
            _slot2.Unhighlight();
        }
        UnSelectObjects(_point0);
        SetEnable(_direction0, false);
    }
    static bool SetComponent(UIBlock block, ref UspElement element)
    {
        PropertyList propList = block.GetProperties();
        TaggedObject[] tagObs = propList.GetTaggedObjectVector("SelectedObjects");

        //если не деселект
        if (tagObs.Length > 0)
        {
            Component parentComponent = Config.FindCompByBodyTag(tagObs[0].Tag);
            if (Geom.IsComponent(tagObs[0]))
            {
                Logger.WriteLine("Объект - " + tagObs[0] +
                    " - " + parentComponent.Name);

                element = new UspElement(parentComponent);
                return true;
            }
            string message = "Выбрана не деталь УСП!" + Environment.NewLine +
                             "Пожалуйста, перевыберите элемент.";
            Logger.WriteWarning(message);
            Logger.WriteLine("Объект - " + tagObs[0]);
            UnSelectObjects(block);

            Config.TheUi.NXMessageBox.Show("Error!",
                                           NXMessageBox.DialogType.Error,
                                           message);

            block.Focus();
            return false;
        }
        Logger.WriteLine("Деселект объекта.");
        return false;
    }

    void SetFirstFace(UIBlock block)
    {
        if (SetFace(block, ref _tunnel1, _element1))
        {
            SetEnable(_slotTunPoint, true);
        }
        else
        {
            SetEnable(_slotTunPoint, false);
        }
        _firstPointSelected = false;
        if (_slot1 != null)
        {
            _slot1.Unhighlight();
        }
        UnSelectObjects(_slotTunPoint);
        SetEnable(_direction0, false);
    }
    static bool SetFace(UIBlock block, ref Tunnel tunnel, UspElement element)
    {
        PropertyList propertyList = block.GetProperties();
        TaggedObject[] to = propertyList.GetTaggedObjectVector("SelectedObjects");

        //если не деселект
        if (to.Length > 0)
        {
            Face face;
            if (FindFace(to, element, out face))
	        {
                if (face.SolidFaceType == Face.FaceType.Cylindrical)
                {

                    Logger.WriteLine("Грань выбрана - " + face);
                    tunnel = new Tunnel(face, element);
                    return true;
                }
	            const string message = "Грань не цилиндрическая! Выберите другую грань!";
	            Logger.WriteWarning(message + Environment.NewLine + "Выбрана грань - " + face);
	            UnSelectObjects(block);
	            Config.TheUi.NXMessageBox.Show("Error!",
	                                           NXMessageBox.DialogType.Error,
	                                           message);
	            block.Focus();
	            return false;
	        }

            const string mess = "Грань не найдена! Выберите другую грань!";
            Logger.WriteWarning(mess);
            Config.TheUi.NXMessageBox.Show("Error!",
                                           NXMessageBox.DialogType.Error,
                                           mess);
            block.Focus();
            return false;
        }
        Logger.WriteLine("Деселект грани");
        return false;
    }
    
/*
    bool findFaceOooooold(TaggedObject[] to, UspElement element, out Face face)
    {
        TaggedObject t = to[0];

        PartCollection PC = Config.TheSession.Parts;
        foreach (Part p in PC)
        {
            Config.TheUi.NXMessageBox.Show("tst", NXMessageBox.DialogType.Error, p.ToString());
            BodyCollection BC = p.Bodies;

            foreach (Body b in BC)
            {
                Config.TheUi.NXMessageBox.Show("tst", NXMessageBox.DialogType.Error, b.ToString());
                Face[] FC = b.GetFaces();

                foreach (Face f in FC)
                {
                    if (f.Tag == t.Tag)
                    {
                        Config.TheUi.NXMessageBox.Show("tst", NXMessageBox.DialogType.Error, f.Tag.ToString() + " | " + f.JournalIdentifier);
                        int type;
                        double[] point = new double[3];
                        double[] dir = new double[3];
                        double[] box = new double[6];
                        double radius;
                        double raddata;
                        int normDir;

                        Config.TheUfSession.Modl.AskFaceData(f.Tag, out type, point, dir, box, out radius,
                            out raddata, out normDir);

                        foreach (Face ff in element.Body.GetFaces())
                        {
                            int type2;
                            double[] point2 = new double[3];
                            double[] dir2 = new double[3];
                            double[] box2 = new double[6];
                            double radius2;
                            double raddata2;
                            int normDir2;

                            Config.TheUfSession.Modl.AskFaceData(ff.Tag, out type2, point2, dir2, box2,
                                out radius2, out raddata2, out normDir2);

                            if (type == type2 && normDir == normDir2 &&
                                Config.Round(radius) == Config.Round(radius2) &&
                                Config.Round(raddata) == Config.Round(raddata2) &&
                                Geom.IsEqual(point, point2) && Geom.IsEqual(dir, dir2))
                            {
                                //Config.theUI.NXMessageBox.Show("tst", NXMessageBox.DialogType.Error, ff.Tag.ToString() + " | " + ff.JournalIdentifier);

                                //tst
                                Part prt = (Part)element.ElementComponent.OwningPart;
                                Config.TheUi.NXMessageBox.Show("tsttttt", NXMessageBox.DialogType.Error, prt.ToString());
                                BodyCollection bbb = prt.Bodies;
                                string sttt = "";
                                foreach (Body var in bbb)
	                            {
                                    Config.TheUi.NXMessageBox.Show("tstttt", NXMessageBox.DialogType.Error, var.ToString());
                                    foreach (Face ss in var.GetFaces())
                                    {
                                        sttt += ss.Tag.ToString() + " ++ " + ff.JournalIdentifier + Environment.NewLine;
                                    }
                                    Logger.WriteLine(sttt);
                                    
                            		 //Config.theUI.NXMessageBox.Show("tst", NXMessageBox.DialogType.Error, var.ToString());
	                            }



                                face = ff;
                                return true;
                            }
                        }
                    }
                }
            }
        }
        face = null;
        return false;
    }
*/

    static bool FindFace(TaggedObject[] to, UspElement element, out Face face)
    {
        TaggedObject t = to[0];

        Part p = (Part)element.ElementComponent.OwningPart;
        BodyCollection bc = p.Bodies;
        foreach (Body b in bc)
        {
            Face[] fc = b.GetFaces();

            foreach (Face f in fc)
            {
                if (f.Tag != t.Tag) continue;
                face = f;
                return true;
            }
        }

        face = null;
        return false;
    }

    void SetFirstPoint(UIBlock block)
    {
        if (SetPoint(block, ref _slotSet1))
        {
            if (_firstPointSelected)
            {
                _slot1.Unhighlight();
            }
            _firstPointSelected = true;

            _hasNearestSlot1 = _slotSet1.HasNearestSlot(out _slot1);

            if (_hasNearestSlot1 && Geom.PointIsBetweenStraights(_tunnel1.CentralPoint, 
                                   new Platan(_slotSet1.BottomFace), 
                                   new Straight(_slot1.EdgeLong1), new Straight(_slot1.EdgeLong2)))
            {
                _slot1.Highlight();
                SetConstraints();
            }
            else
            {
                string message = "Базовое отверстие не пересекается с пазом!" + Environment.NewLine +
                         "Выберите другое отверстие или паз!";
                Logger.WriteWarning(message);
                Config.TheUi.NXMessageBox.Show("Error!",
                                               NXMessageBox.DialogType.Error,
                                               message);
                _firstPointSelected = false;
                UnSelectObjects(_slotTunPoint);
                _slotTunPoint.Focus();
            }
        }
        else
        {
            _firstPointSelected = false;
            SetEnable(block, false);

            UnSelectObjects(_faceSelect0);
            SetEnable(_faceSelect0, false);

            UnSelectObjects(_selection0);
            _selection0.Focus();
        }
    }
    void SetSecondPoint(UIBlock block)
    {
        if (SetPoint(block, ref _slotSet2))
        {
            if (_secondPointSelected)
            {
                _slot2.Unhighlight();
            }
            _secondPointSelected = true;
            _hasNearestSlot2 = _slotSet2.HasNearestSlot(out _slot2);

            _slot2.Highlight();
            SetConstraints();
        }
        else
        {
            _secondPointSelected = false;
            SetEnable(block, false);

            UnSelectObjects(_selection01);
            _selection01.Focus();
        }
    }

    static bool SetPoint(UIBlock block, ref SlotSet slotSet)
    {
        PropertyList propertyList = block.GetProperties();
        Point3d point = propertyList.GetPoint("Point");

        if (SetPoint(point, ref slotSet))
        {
            return true;
        }
        string message = "Базовые плоскости пазов не найдены!" + Environment.NewLine +
                         "Выберите другой элемент!";
        Logger.WriteWarning(message);
        Config.TheUi.NXMessageBox.Show("Error!",
                                       NXMessageBox.DialogType.Error,
                                       message);
        UnSelectObjects(block);
        return false;
    }
    static bool SetPoint(Point3d point, ref SlotSet slotSet)
    {
        slotSet.SetPoint(point);
        if (slotSet.HaveNearestBottomFace())
        {
            slotSet.SetNearestEdges();

            return true;
        }
        return false;
    }

    static void SetEnable(UIBlock block, bool enable)
    {
        PropertyList propList = block.GetProperties();
        propList.SetLogical("Enable", enable);
    }

    static void UnSelectObjects(UIBlock block)
    {
        PropertyList propList = block.GetProperties();
        propList.SetTaggedObjectVector("SelectedObjects", new TaggedObject[0]);
    }

    static void UnSelectSlot(Slot slot, UIBlock slotSetBlock)
    {
        if (slot != null)
        {
            slot.Unhighlight();
        }
        UnSelectObjects(slotSetBlock);
        SetEnable(slotSetBlock, false);
    }



    /// <summary>
    /// Получение имени сервера
    /// </summary>    
    /// <param name="serverString">       
    /// строка сервера</param>
    /// <returns>Имя сервера</returns>
    private static string findCorrectServerName(String serverString)
    {
        int positionOfSym = 0, i = 0;

        String correctServerString = "";

        foreach (char findSym in serverString)
        {
            if (String.Compare((Convert.ToString(findSym)), "/") == 0)
            {
                positionOfSym = i;
            }

            i++;

        }

        if (positionOfSym == 0)
        {
            return serverString;
        }

        i = 0;


        foreach (char findSym in serverString)
        {

            if (i > positionOfSym)
            {
                correctServerString += findSym;
            }

            i++;

        }

        return correctServerString;

    }

    private static void doMagic()
    {
        SQLOracle.BuildConnectionString("591014", "591000", "BASEEOI");
        SqlOracle.BuildConnectionString("591014", "591000", "BASEEOI");

        Dictionary<string, string> dict = new Dictionary<string, string>();
        dict.Add("diametr", "%12%");
        dict.Add("length", "50");

        Dictionary<string, string> dictionary;
        SqlOracle.Sel("select OBOZN, L from DB_DATA where KATALOG_USP = 1 and GROUP_USP = 5 and D like :diametr and L >= :length and NAME = 'Болты  пазовые'", dict, out dictionary);

        string title = "";
        int minLen = int.MaxValue;
        foreach (KeyValuePair<string, string> keyValuePair in dictionary)
        {
            int len = Int32.Parse(keyValuePair.Value);
            if (len >= minLen) continue;
            title = keyValuePair.Key;
            minLen = len;
        }

        Katalog2005.Algorithm.SpecialFunctions.DefineTypeOfModel(title);
    }


    void SetConstraints()
    {
        if (!_firstPointSelected || !_secondPointSelected) return;
        Logger.WriteLine("Запущена процедура позиционирования.");

        if (_hasNearestSlot1 && _hasNearestSlot2)
        {
            _tunnel1.SetSlot(_slot1);

            doMagic();
            UspElement fixture = new UspElement(Katalog2005.Algorithm.SpecialFunctions.UnLoadedPart);

            _constraint = new TunnelSlotConstraint(_element1, _tunnel1, _element2, _slot2, fixture);
            _constraint.Create();

            SetEnable(_direction0, true);
        }
        else
        {
            string mess = "Ближайший слот для первого элемента найден - " + _hasNearestSlot1 +
                          Environment.NewLine;
            mess += "Ближайший слот для второго элемента найден - " + _hasNearestSlot2;
            Logger.WriteLine(mess);
        }
    }

    static void CleanUp()
    {
        if (_slot1 != null)
        {
            _slot1.Unhighlight();
        }
        if (_slot2 != null)
        {
            _slot2.Unhighlight();
        }
        _secondPointSelected = false;
        _firstPointSelected = false;

        _hasNearestSlot1 = false;
        _hasNearestSlot2 = false;
    }

}