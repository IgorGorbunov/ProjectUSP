//==============================================================================
//  WARNING!!  This file is overwritten by the Block UI Styler while generating
//  the automation code. Any modifications to this file will be lost after
//  generating the code again.
//
//       Filename:  C:\ug_customization\application\dialogs\milingBase\milingBase.cs
//
//        This file was generated by the NX Block UI Styler
//        Created by: USP
//              Version: NX 7.5
//              Date: 08-19-2013  (Format: mm-dd-yyyy)
//              Time: 18:51 (Format: hh-mm)
//
//==============================================================================

//==============================================================================
//  Purpose:  This TEMPLATE file contains C# source to guide you in the
//  construction of your Block application dialog. The generation of your
//  dialog file (.dlx extension) is the first step towards dialog construction
//  within NX.  You must now create a NX Open application that
//  utilizes this file (.dlx).
//
//  The information in this file provides you with the following:
//
//  1.  Help on how to load and display your Block UI Styler dialog in NX
//      using APIs provided in NXOpen.BlockStyler namespace
//  2.  The empty callback methods (stubs) associated with your dialog items
//      have also been placed in this file. These empty methods have been
//      created simply to start you along with your coding requirements.
//      The method name, argument list and possible return values have already
//      been provided for you.
//==============================================================================

//------------------------------------------------------------------------------
//These imports are needed for the following template code
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.IO;
using NXOpen;
using NXOpen.Assemblies;
using NXOpen.BlockStyler;
using NXOpen.UF;
using NXOpen.Utilities;


//------------------------------------------------------------------------------
//Represents Block Styler application class
//------------------------------------------------------------------------------
public sealed class MilingBase : DialogProgpam
{
    //class members

    private readonly string _theDialogName;

    private UIBlock _group0; // Block type: Group
    private UIBlock _toggleRoundBase; // Block type: Toggle
    private UIBlock _enumSlotType; // Block type: Enumeration
    private UIBlock _group01; // Block type: Group
    private UIBlock _toggleRectatgularBase; // Block type: Toggle
    private UIBlock _toggleSquareBase; // Block type: Toggle
    private UIBlock _group02; // Block type: Group
    private UIBlock _selection0; // Block type: Selection
    private UIBlock _distanceGroup; // Block type: Group
    private UIBlock _direction0; // Block type: Reverse Direction
    private UIBlock _distance; // Block type: Double
    private UIBlock _parallelGroup; // Block type: Group
    private UIBlock _selection01; // Block type: Selection
    private UIBlock _selection02; // Block type: Selection

    //------------------------------------------

    private Face _selectedFace;

    private Face _topSlotFace;
    private BaseElement _base;

    private bool _isRoundBase;
    private bool _isRectangularBase = true;
    private bool _isSquareBase = true;

    private Parallel _topParallel;

    private double _width, _length;
    private NoRoundBaseData _baseData;

    private readonly double[] _maxDistances = new double[3];
    private CoordinateAxe[] _baseAxes = new CoordinateAxe[2];

    private CoordinateAxe _ortAxe;
    private Vector _moveDirection;
    private Point3d _oldPointMovement, _startMovementPoint;

    private readonly List<Vertex> _absolutePoints = new List<Vertex>();
    private readonly List<Vertex> _projectPoints = new List<Vertex>(); 


    //------------------------------------------------------------------------------
    //Constructor for NX Styler class
    //------------------------------------------------------------------------------
    public MilingBase()
    {
        try
        {
            _theDialogName = AppDomain.CurrentDomain.BaseDirectory +
                             Config.DlxFolder + Path.DirectorySeparatorChar + Config.DlxMilingBase;

            TheDialog = Config.TheUi.CreateDialog(_theDialogName);
            TheDialog.AddApplyHandler(apply_cb);
            TheDialog.AddOkHandler(ok_cb);
            TheDialog.AddUpdateHandler(update_cb);
            TheDialog.AddCancelHandler(cancel_cb);
            TheDialog.AddInitializeHandler(initialize_cb);
            TheDialog.AddFocusNotifyHandler(focusNotify_cb);
            TheDialog.AddKeyboardFocusNotifyHandler(keyboardFocusNotify_cb);
            TheDialog.AddDialogShownHandler(dialogShown_cb);
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            Logger.WriteError(ex.ToString());
            Message.Show(ex);
            throw;
        }
    }

    //------------------------------- DIALOG LAUNCHING ---------------------------------
    //
    //    Before invoking this application one needs to open any part/empty part in NX
    //    because of the behavior of the blocks.
    //
    //    Make sure the dlx file is in one of the following locations:
    //        1.) From where NX session is launched
    //        2.) $UGII_USER_DIR/application
    //        3.) For released applications, using UGII_CUSTOM_DIRECTORY_FILE is highly
    //            recommended. This variable is set to a full directory path to a file 
    //            containing a list of root directories for all custom applications.
    //            e.g., UGII_CUSTOM_DIRECTORY_FILE=$UGII_ROOT_DIR\menus\custom_dirs.dat
    //
    //    You can create the dialog using one of the following way:
    //
    //    1. Journal Replay
    //
    //        1) Replay this file through Tool->Journal->Play Menu.
    //
    //    2. USER EXIT
    //
    //        1) Create the Shared Library -- Refer "Block UI Styler programmer's guide"
    //        2) Invoke the Shared Library through File->Execute->NX Open menu.
    //
    //------------------------------------------------------------------------------


    //------------------------------------------------------------------------------
    // Following method cleanup any housekeeping chores that may be needed.
    // This method is automatically called by NX.
    //------------------------------------------------------------------------------
    // ReSharper disable UnusedMember.Global
    // ReSharper disable UnusedParameter.Global
    public static int UnloadLibrary(string arg)
        // ReSharper restore UnusedParameter.Global
        // ReSharper restore UnusedMember.Global
    {
        try
        {
            //---- Enter your code here -----
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            Config.TheUi.NXMessageBox.Show("Block Styler", NXMessageBox.DialogType.Error,
                                           ex.ToString());
        }
        return 0;
    }



    //------------------------------------------------------------------------------
    //---------------------Block UI Styler Callback Functions--------------------------
    //------------------------------------------------------------------------------

    //------------------------------------------------------------------------------
    //Callback Name: initialize_cb
    //------------------------------------------------------------------------------
    private void initialize_cb()
    {
        try
        {
            _group0 = TheDialog.TopBlock.FindBlock("group0");
            _toggleRoundBase = TheDialog.TopBlock.FindBlock("toggle0");
            _enumSlotType = TheDialog.TopBlock.FindBlock("enum0");
            _group01 = TheDialog.TopBlock.FindBlock("group01");
            _toggleRectatgularBase = TheDialog.TopBlock.FindBlock("toggle01");
            _toggleSquareBase = TheDialog.TopBlock.FindBlock("toggle02");
            _group02 = TheDialog.TopBlock.FindBlock("group02");
            _selection0 = TheDialog.TopBlock.FindBlock("selection0");
            _distanceGroup = TheDialog.TopBlock.FindBlock("group");
            _direction0 = TheDialog.TopBlock.FindBlock("direction0");
            _distance = TheDialog.TopBlock.FindBlock("double0");
            _parallelGroup = TheDialog.TopBlock.FindBlock("group1");
            _selection01 = TheDialog.TopBlock.FindBlock("selection01");
            _selection02 = TheDialog.TopBlock.FindBlock("selection02");
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            Logger.WriteError(ex.ToString());
            Message.Show("Block Styler", Message.MessageIcon.Error, ex);
        }
    }

    //------------------------------------------------------------------------------
    //Callback Name: dialogShown_cb
    //This callback is executed just before the dialog launch. Thus any value set 
    //here will take precedence and dialog will be launched showing that value. 
    //------------------------------------------------------------------------------
    private void dialogShown_cb()
    {
        try
        {
            //---- Enter your callback code here -----
            Selection.MaskTriple[] mask = new Selection.MaskTriple[1];
            mask[0].Type = UFConstants.UF_solid_type;
            mask[0].Subtype = UFConstants.UF_all_subtype;
            mask[0].SolidBodySubtype = UFConstants.UF_UI_SEL_FEATURE_PLANAR_FACE;
            _selection0.GetProperties()
                       .SetSelectionFilter("SelectionFilter",
                                           Selection.SelectionAction.ClearAndEnableSpecific, mask);

            PropertyList propertyList = _distance.GetProperties();
            propertyList.SetDouble("Value", 0.0);
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            Logger.WriteError(ex.ToString());
            Message.Show("Block Styler", Message.MessageIcon.Error, ex);
        }
    }

    //------------------------------------------------------------------------------
    //Callback Name: apply_cb
    //------------------------------------------------------------------------------
    private int apply_cb()
    {
        int errorCode = 0;
        try
        {
            //---- Enter your callback code here -----
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            errorCode = 1;
            Logger.WriteError(ex.ToString());
            Message.Show("Block Styler", Message.MessageIcon.Error, ex);
        }
        return errorCode;
    }

    //------------------------------------------------------------------------------
    //Callback Name: update_cb
    //------------------------------------------------------------------------------
    private int update_cb(UIBlock block)
    {
        try
        {
            if (block == _toggleRoundBase)
            {
                //---------Enter your code here-----------
                Logger.WriteLine("Нажат переключатель выбора круглых баз.");
                PropertyList trbProp = _toggleRoundBase.GetProperties();
                bool value = trbProp.GetLogical("Value");
                SetEnum(!value);
            }
            else if (block == _enumSlotType)
            {
                //---------Enter your code here-----------
            }
            else if (block == _toggleRectatgularBase)
            {
                //---------Enter your code here-----------
                Logger.WriteLine("Нажат выбор прямоугольных баз.");
                SetToggle(block, out _isRectangularBase);
                SetEnableToggles();
            }
            else if (block == _toggleSquareBase)
            {
                //---------Enter your code here-----------
                Logger.WriteLine("Нажат выбор квадратных баз.");
                SetToggle(block, out _isSquareBase);
                SetEnableToggles();
            }
            else if (block == _selection0)
            {
                //---------Enter your code here-----------
                Logger.WriteLine("Нажат выбор грани, параллельной базе.");
                SetFace(block);
                SetPoints();
            }
            else if (block == _direction0)
            {
                //---------Enter your code here-----------
            }
            else if (block == _distance)
            {
                //---------Enter your code here-----------
                PanBase(block);
            }
            else if (block == _selection01)
            {
                //---------Enter your code here-----------
            }
            else if (block == _selection02)
            {
                //---------Enter your code here-----------
            }
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            Logger.WriteError(ex.ToString());
            Message.Show("Block Styler", Message.MessageIcon.Error, ex);
        }
        return 0;
    }

    //------------------------------------------------------------------------------
    //Callback Name: ok_cb
    //------------------------------------------------------------------------------
    private int ok_cb()
    {
        int errorCode;
        try
        {
            errorCode = apply_cb();
            //---- Enter your callback code here -----
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            errorCode = 1;
            Logger.WriteError(ex.ToString());
            Message.Show("Block Styler", Message.MessageIcon.Error, ex);
        }
        return errorCode;
    }

    //------------------------------------------------------------------------------
    //Callback Name: cancel_cb
    //------------------------------------------------------------------------------
    private int cancel_cb()
    {
        try
        {
            //---- Enter your callback code here -----
            Logger.WriteLine("Нажата кнопка Отмена.");
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            Message.Show(ex);
        }
        return 0;
    }


    //------------------------------------------------------------------------------
    //Callback Name: focusNotify_cb
    //This callback is executed when any block (except the ones which receive keyboard entry such as Integer block) receives focus.
    //------------------------------------------------------------------------------
    private void focusNotify_cb(UIBlock block, bool focus)
    {
        try
        {
            //---- Enter your callback code here -----
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            Logger.WriteError(ex.ToString());
            Message.Show("Block Styler", Message.MessageIcon.Error, ex);
        }
    }

    //------------------------------------------------------------------------------
    //Callback Name: keyboardFocusNotify_cb
    //This callback is executed when block which can receive keyboard entry, receives the focus.
    //------------------------------------------------------------------------------
    private void keyboardFocusNotify_cb(UIBlock block, bool focus)
    {
        try
        {
            //---- Enter your callback code here -----
        }
        catch (Exception ex)
        {
            //---- Enter your exception handling code here -----
            Logger.WriteError(ex.ToString());
            Message.Show("Block Styler", Message.MessageIcon.Error, ex);
        }
    }

    //-------------------------------------

    private void SetEnum(bool enable)
    {
        PropertyList propertyList = _enumSlotType.GetProperties();
        SetEnable(propertyList, enable);
        if (!enable)
        {
            propertyList.SetEnum("Value", 0);
        }
    }

    private void SetToggle(UIBlock uiBlock, out bool isSet)
    {
        PropertyList propertyList = uiBlock.GetProperties();
        isSet = propertyList.GetLogical("Value");
    }

    private void SetEnableToggles()
    {
        SetEnable(_toggleSquareBase, _isRectangularBase);
        SetEnable(_toggleRectatgularBase, _isSquareBase);
    }

    //------------------------------------

    private void SetPoints()
    {
        SetAbsolutePoints();
        SetMaxDistances();
        SetProjectPoints();
        GetSurfaceAxes();
        SetSize();
        _baseData = GetBase();
        LoadBase();
        SetTopParallel();
        MoveBase();
    }

    private void SetAbsolutePoints()
    {
        _absolutePoints.Clear();
        PartCollection partCollection = Config.TheSession.Parts;

        Logger.WriteLine("Пишем точки");
        foreach (Part part in partCollection)
        {
            Tag[] occurences;
            Config.TheUfSession.Assem.AskOccsOfPart(Config.WorkPart.Tag, part.Tag, out occurences);

            foreach (Tag tag in occurences)
            {
                Component component = (Component) NXObjectManager.Get(tag);
                if (component.IsBlanked) continue;

                UspElement element = new UspElement(component);

                double[] minCorner = new double[3];
                double[] distances = new double[3];
                double[,] directions = new double[3,3];
                Config.TheUfSession.Modl.AskBoundingBoxExact(element.Body.Tag, Tag.Null, minCorner,
                                                             directions, distances);

                _absolutePoints.Add(new Vertex(minCorner[0], minCorner[1], minCorner[2]));
                _absolutePoints.Add(new Vertex(minCorner[0] + distances[0], minCorner[1],
                                               minCorner[2]));
                _absolutePoints.Add(new Vertex(minCorner[0], minCorner[1] + distances[1],
                                               minCorner[2]));
                _absolutePoints.Add(new Vertex(minCorner[0], minCorner[1],
                                               minCorner[2] + distances[2]));

                _absolutePoints.Add(new Vertex(minCorner[0] + distances[0],
                                               minCorner[1] + distances[1], minCorner[2]));
                _absolutePoints.Add(new Vertex(minCorner[0] + distances[0], minCorner[1],
                                               minCorner[2] + distances[2]));
                _absolutePoints.Add(new Vertex(minCorner[0], minCorner[1] + distances[1],
                                               minCorner[2] + distances[2]));
                _absolutePoints.Add(new Vertex(minCorner[0] + distances[0],
                                               minCorner[1] + distances[1],
                                               minCorner[2] + distances[2]));
            }
        }
    }

    private void SetMaxDistances()
    {
        CoordinateAxe[] axes = new CoordinateAxe[3];
        axes[0] = new XAxe();
        axes[1] = new YAxe();
        axes[2] = new ZAxe();
        for (int i = 0; i < _maxDistances.Length; i++)
        {
            _maxDistances[i] = GetMaxDistance(axes[i]);
            Logger.WriteLine("Максимальная дистанция по оси " + axes[i] + 
                " - " + _maxDistances[i]);
        }
    }

    private double GetMaxDistance(CoordinateAxe axe)
    {
        double min = double.MaxValue, max = double.MinValue;
        foreach (Vertex vertex in _absolutePoints)
        {
            if (vertex.GetCoordinate(axe) < min)
            {
                min = vertex.GetCoordinate(axe);
            }
            if (vertex.GetCoordinate(axe) > max)
            {
                max = vertex.GetCoordinate(axe);
            }
        }

        return max - min;
    }

    private void SetProjectPoints()
    {
        _projectPoints.Clear();
        Surface surface = new Surface(_selectedFace);
        foreach (Vertex absoluteVertex in _absolutePoints)
        {
            Vertex projectVertex = surface.GetProection(absoluteVertex);

            bool alreadyHave = false;
            foreach (Vertex vertex in _projectPoints)
            {
                if (!Geom.IsEqual(projectVertex, vertex)) continue;

                alreadyHave = true;
                break;
            }
            if (!alreadyHave)
            {
                _projectPoints.Add(projectVertex); 
            }
        }
    }

    private void GetSurfaceAxes()
    {
        int axeType = 0;
        double min = double.MaxValue;
        for (int i = 0; i < _maxDistances.Length; i++)
        {
            if (_maxDistances[i] > min) continue;

            min = _maxDistances[i];
            axeType = i+1;
        }
        Logger.WriteLine("Минимальное расстояние в сборке - " + min + " по оси " + (CoordinateConfig.Type)axeType);
        _baseAxes = CoordinateConfig.GetSurfaceAxes((CoordinateConfig.Type) axeType);
        _ortAxe = CoordinateConfig.GetAxe((CoordinateConfig.Type) axeType);
        _moveDirection = new Vector(_ortAxe);
        Logger.WriteLine("База будет расположена в плоскости " + _baseAxes[0].Type + _baseAxes[1].Type);
    }

    private void SetSize()
    {
        if (_maxDistances[((int)_baseAxes[0].Type) - 1] > _maxDistances[((int)_baseAxes[1].Type) - 1])
        {
            _length = _maxDistances[((int) _baseAxes[0].Type) - 1];
            _width = _maxDistances[((int)_baseAxes[1].Type) - 1];
        }
        else
        {
            _length = _maxDistances[((int)_baseAxes[1].Type) - 1];
            _width = _maxDistances[((int)_baseAxes[0].Type) - 1];
        }
        Logger.WriteLine("Размеры базовой плиты должны быть не меньше " + _length + " x " + _width);
    }

    private NoRoundBaseData GetBase()
    {
        List<NoRoundBaseData> bases = new List<NoRoundBaseData>();
        string selectColumns = GetColumns_Round();
        string coditions = GetCondition_Round() + GetCondition_Slot() + GetCondition_NoRound();
        

        return SqlUspElement.GetNoRoundBase(_length, _width, selectColumns, coditions, new Catalog8());
    }

    private void LoadBase()
    {
        Katalog2005.Algorithm.SpecialFunctions.LoadPart(_baseData.Title, false);
        _base = new BaseElement(Katalog2005.Algorithm.SpecialFunctions.LoadedPart);
        _topSlotFace = _base.TopSlotFace;
    }

    private string GetColumns_Round()
    {
        //case when L = 0 then D else L end as Len,
        //case when L = 0 then D else B end as Wid 
        PropertyList propertyList = _toggleRoundBase.GetProperties();
        bool value = propertyList.GetLogical("Value");
        //без круглых плит
        if (value)
        {
            return SqlTabUspData.CLength + " as Len," + SqlTabUspData.CWidth + " as Wid ";
        }
        return "case when " + SqlTabUspData.CLength + " = 0 then " +
               SqlTabUspData.CDiametr + " else " + SqlTabUspData.CLength + " end as Len," +
               "case when " + SqlTabUspData.CLength + " = 0 then " +
               SqlTabUspData.CDiametr + " else " + SqlTabUspData.CWidth + " end as Wid ";
    }

    private string GetCondition_Round()
    {
        //--and TO_NUMBER(L) > 0 --некруглые плиты
        //--and (NAME like 'Плита круглая%' or NAME like 'Плиты круглые%') --круглые плиты
        PropertyList propertyList = _toggleRoundBase.GetProperties();
        bool value = propertyList.GetLogical("Value");
        //без круглых плит
        if (value)
        {
            _isRoundBase = false;
            return " and TO_NUMBER(" + SqlTabUspData.CLength + ") > 0";
        }
        _isRoundBase = true;
        return " and (" + SqlTabUspData.CName + " like '" + SqlTabUspData.GetName(SqlTabUspData.NameUsp.RoundPlate) + "%' or " +
            SqlTabUspData.CName + " like '" + SqlTabUspData.GetName(SqlTabUspData.NameUsp.RoundPlates) + "%')";
    }

    private string GetCondition_Slot()
    {
        //--and NAME like '%радиальн%' --радиально-поперечное расположение пазов
        //--and NAME not like '%радиальн%' --крестообразное расположение пазов
        PropertyList propertyList = _enumSlotType.GetProperties();
        bool enable = propertyList.GetLogical("Enable");
        if (!enable)
        {
            return "";
        }

        string slotType = propertyList.GetEnumAsString("Value");
        if (slotType == "Крестообразное")
        {
            return " and " + SqlTabUspData.CName + " not like '%" + 
                SqlTabUspData.GetName(SqlTabUspData.NameUsp.RadialPlate) + "%'";
        }
        return " and " + SqlTabUspData.CName + " like '%" +
                SqlTabUspData.GetName(SqlTabUspData.NameUsp.RadialPlate) + "%'";

    }

    private string GetCondition_NoRound()
    {
        //--and L = B --квадратные
        //--and L <> B --прямоугольные
        PropertyList rectPropList = _toggleRectatgularBase.GetProperties();
        bool rectValue = rectPropList.GetLogical("Value");
        PropertyList sqrPropList = _toggleSquareBase.GetProperties();
        bool sqrValue = sqrPropList.GetLogical("Value");
        if (sqrValue && rectValue)
        {
            return "";
        }
        if (sqrValue)
        {
            return " and " + SqlTabUspData.CLength + " = " + SqlTabUspData.CWidth;
        }
        //if (rectValue)
        return " and " + SqlTabUspData.CLength + " <> " + SqlTabUspData.CWidth;
    }

    private void SetFace(UIBlock block)
    {
        PropertyList propertyList = block.GetProperties();
        TaggedObject[] taggedObjects =
            propertyList.GetTaggedObjectVector("SelectedObjects");
        SetEnable(_distanceGroup, taggedObjects.Length > 0);

        _selectedFace = (Face)taggedObjects[0];
        Logger.WriteLine("Выбрана грань " + _selectedFace);
    }

    private void SetTopParallel()
    {
        bool isFixed = _base.ElementComponent.IsFixed;
        if (!isFixed)
        {
            _base.Fix();
        }
        _topParallel = new Parallel();
        _topParallel.Create(_selectedFace.OwningComponent, _selectedFace,
                            Katalog2005.Algorithm.SpecialFunctions.LoadedPart, _topSlotFace);
        if (!isFixed)
        {
            _base.Unfix();
        }
    }

    private void MoveBase()
    {
        Vertex assVertex = GetAssCenterVertex();
        Vertex baseVertex = GetBaseCenterVertex();
        Vector direction = new Vector(baseVertex.Point, assVertex.Point);
        Movement.MoveByDirection(_base.ElementComponent, direction);
        _oldPointMovement = GetBaseCenterVertex().Point;
        _startMovementPoint = _oldPointMovement;
    }

    private Vertex GetAssCenterVertex()
    {
        double[] min = {double.MaxValue, double.MaxValue};
        double[] max = {double.MinValue, double.MinValue};
        Vertex someVertex = null;
        foreach (Vertex vertex in _projectPoints)
        {
            if (someVertex == null)
            {
                someVertex = vertex;
            }
            for (int i = 0; i < _baseAxes.Length; i++)
            {
                double coord = vertex.GetCoordinate(_baseAxes[i]);
                if (coord < min[i])
                {
                    min[i] = coord;
                }
                if (coord > max[i])
                {
                    max[i] = coord;
                }
            }
        }
        double xCoord = 0.0;
        double yCoord = 0.0;
        double zCoord = 0.0;
        for (int i = 0; i < _baseAxes.Length; i++)
        {
            switch (_baseAxes[i].Type)
            {
                case CoordinateConfig.Type.X:
                    xCoord = (max[i] + min[i])/2;
                    break;
                case CoordinateConfig.Type.Y:
                    yCoord = (max[i] + min[i]) / 2;
                    break;
                case CoordinateConfig.Type.Z:
                    zCoord = (max[i] + min[i]) / 2;
                    break;
            }
        }
        Vertex centerVertex = new Vertex(xCoord, yCoord, zCoord);
        centerVertex.SetCoordinate(_ortAxe, someVertex.GetCoordinate(_ortAxe));
        return centerVertex;
    }

    private Vertex GetBaseCenterVertex()
    {
        double[] minCorner = new double[3];
        double[] distances = new double[3];
        double[,] directions = new double[3, 3];
        Config.TheUfSession.Modl.AskBoundingBoxExact(_base.Body.Tag, Tag.Null, minCorner, directions, distances);

        List<Vertex> vertices = new List<Vertex>();
        Instr.AddUnicToList(vertices, new Point3d(minCorner[0], minCorner[1], minCorner[2]));
        Instr.AddUnicToList(vertices, new Point3d(minCorner[0] + distances[0], minCorner[1], minCorner[2]));
        Instr.AddUnicToList(vertices, new Point3d(minCorner[0], minCorner[1] + distances[1], minCorner[2]));
        Instr.AddUnicToList(vertices, new Point3d(minCorner[0], minCorner[1], minCorner[2] + distances[2]));

        Instr.AddUnicToList(vertices, new Point3d(minCorner[0] + distances[0], minCorner[1] + distances[1], minCorner[2]));
        Instr.AddUnicToList(vertices, new Point3d(minCorner[0] + distances[0], minCorner[1], minCorner[2] + distances[2]));
        Instr.AddUnicToList(vertices, new Point3d(minCorner[0], minCorner[1] + distances[1], minCorner[2] + distances[2]));
        Instr.AddUnicToList(vertices, new Point3d(minCorner[0] + distances[0], minCorner[1] + distances[1], minCorner[2] + distances[2]));

        double[] min = { double.MaxValue, double.MaxValue };
        double[] max = { double.MinValue, double.MinValue };
        Vertex someVertex = null;
        foreach (Vertex vertex in vertices)
        {
            Surface surface = new Surface(_base.TopSlotFace);
            Vertex pVertex = surface.GetProection(vertex);
            if (someVertex == null)
            {
                someVertex = pVertex;
            }
            for (int i = 0; i < _baseAxes.Length; i++)
            {
                double coord = pVertex.GetCoordinate(_baseAxes[i]);
                if (coord < min[i])
                {
                    min[i] = coord;
                }
                if (coord > max[i])
                {
                    max[i] = coord;
                }
            }
        }

        double xCoord = 0.0;
        double yCoord = 0.0;
        double zCoord = 0.0;
        for (int i = 0; i < _baseAxes.Length; i++)
        {
            switch (_baseAxes[i].Type)
            {
                case CoordinateConfig.Type.X:
                    xCoord = (max[i] + min[i]) / 2;
                    break;
                case CoordinateConfig.Type.Y:
                    yCoord = (max[i] + min[i]) / 2;
                    break;
                case CoordinateConfig.Type.Z:
                    zCoord = (max[i] + min[i]) / 2;
                    break;
            }
        }
        Vertex centerVertex = new Vertex(xCoord, yCoord, zCoord);
        centerVertex.SetCoordinate(_ortAxe, someVertex.GetCoordinate(_ortAxe));
        return centerVertex;
    }

    private void PanBase(UIBlock block)
    {
        PropertyList propertyList = block.GetProperties();
        double doub = propertyList.GetDouble("Value");
        Point3d newPoint = _moveDirection.GetPoint(_startMovementPoint, doub);
        Vector newVector = new Vector(_oldPointMovement, newPoint);
        Movement.MoveByDirection(_base.ElementComponent, newVector);
        _oldPointMovement = newPoint;
    }


}